{"ast":null,"code":"import { textContent } from 'domutils';\nimport { flattenOptions } from './options.js';\n/**\n * Helper function to render a DOM.\n *\n * @param that - Cheerio instance to render.\n * @param dom - The DOM to render. Defaults to `that`'s root.\n * @param options - Options for rendering.\n * @returns The rendered document.\n */\nfunction render(that, dom, options) {\n  if (!that) return '';\n  return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, undefined, options).toString();\n}\n/**\n * Checks if a passed object is an options object.\n *\n * @param dom - Object to check if it is an options object.\n * @param options - Options object.\n * @returns Whether the object is an options object.\n */\nfunction isOptions(dom, options) {\n  return !options && typeof dom === 'object' && dom != null && !('length' in dom) && !('type' in dom);\n}\nexport function html(dom, options) {\n  /*\n   * Be flexible about parameters, sometimes we call html(),\n   * with options as only parameter\n   * check dom argument for dom element specific properties\n   * assume there is no 'length' or 'type' properties in the options object\n   */\n  const toRender = isOptions(dom) ? (options = dom, undefined) : dom;\n  /*\n   * Sometimes `$.html()` is used without preloading html,\n   * so fallback non-existing options to the default ones.\n   */\n  const opts = {\n    ...(this === null || this === void 0 ? void 0 : this._options),\n    ...flattenOptions(options)\n  };\n  return render(this, toRender, opts);\n}\n/**\n * Render the document as XML.\n *\n * @category Static\n * @param dom - Element to render.\n * @returns THe rendered document.\n */\nexport function xml(dom) {\n  const options = {\n    ...this._options,\n    xmlMode: true\n  };\n  return render(this, dom, options);\n}\n/**\n * Render the document as text.\n *\n * This returns the `textContent` of the passed elements. The result will\n * include the contents of `<script>` and `<style>` elements. To avoid this, use\n * `.prop('innerText')` instead.\n *\n * @category Static\n * @param elements - Elements to render.\n * @returns The rendered document.\n */\nexport function text(elements) {\n  const elems = elements !== null && elements !== void 0 ? elements : this ? this.root() : [];\n  let ret = '';\n  for (let i = 0; i < elems.length; i++) {\n    ret += textContent(elems[i]);\n  }\n  return ret;\n}\nexport function parseHTML(data, context, keepScripts = typeof context === 'boolean' ? context : false) {\n  if (!data || typeof data !== 'string') {\n    return null;\n  }\n  if (typeof context === 'boolean') {\n    keepScripts = context;\n  }\n  const parsed = this.load(data, this._options, false);\n  if (!keepScripts) {\n    parsed('script').remove();\n  }\n  /*\n   * The `children` array is used by Cheerio internally to group elements that\n   * share the same parents. When nodes created through `parseHTML` are\n   * inserted into previously-existing DOM structures, they will be removed\n   * from the `children` array. The results of `parseHTML` should remain\n   * constant across these operations, so a shallow copy should be returned.\n   */\n  return [...parsed.root()[0].children];\n}\n/**\n * Sometimes you need to work with the top-level root element. To query it, you\n * can use `$.root()`.\n *\n * @category Static\n * @example\n *\n * ```js\n * $.root().append('<ul id=\"vegetables\"></ul>').html();\n * //=> <ul id=\"fruits\">...</ul><ul id=\"vegetables\"></ul>\n * ```\n *\n * @returns Cheerio instance wrapping the root node.\n * @alias Cheerio.root\n */\nexport function root() {\n  return this(this._root);\n}\n/**\n * Checks to see if the `contained` DOM element is a descendant of the\n * `container` DOM element.\n *\n * @category Static\n * @param container - Potential parent node.\n * @param contained - Potential child node.\n * @returns Indicates if the nodes contain one another.\n * @alias Cheerio.contains\n * @see {@link https://api.jquery.com/jQuery.contains/}\n */\nexport function contains(container, contained) {\n  // According to the jQuery API, an element does not \"contain\" itself\n  if (contained === container) {\n    return false;\n  }\n  /*\n   * Step up the descendants, stopping when the root element is reached\n   * (signaled by `.parent` returning a reference to the same object)\n   */\n  let next = contained;\n  while (next && next !== next.parent) {\n    next = next.parent;\n    if (next === container) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Extract multiple values from a document, and store them in an object.\n *\n * @category Static\n * @param map - An object containing key-value pairs. The keys are the names of\n *   the properties to be created on the object, and the values are the\n *   selectors to be used to extract the values.\n * @returns An object containing the extracted values.\n */\nexport function extract(map) {\n  return this.root().extract(map);\n}\n/**\n * $.merge().\n *\n * @category Static\n * @param arr1 - First array.\n * @param arr2 - Second array.\n * @returns `arr1`, with elements of `arr2` inserted.\n * @alias Cheerio.merge\n * @see {@link https://api.jquery.com/jQuery.merge/}\n */\nexport function merge(arr1, arr2) {\n  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {\n    return;\n  }\n  let newLength = arr1.length;\n  const len = +arr2.length;\n  for (let i = 0; i < len; i++) {\n    arr1[newLength++] = arr2[i];\n  }\n  arr1.length = newLength;\n  return arr1;\n}\n/**\n * Checks if an object is array-like.\n *\n * @category Static\n * @param item - Item to check.\n * @returns Indicates if the item is array-like.\n */\nfunction isArrayLike(item) {\n  if (Array.isArray(item)) {\n    return true;\n  }\n  if (typeof item !== 'object' || item === null || !('length' in item) || typeof item.length !== 'number' || item.length < 0) {\n    return false;\n  }\n  for (let i = 0; i < item.length; i++) {\n    if (!(i in item)) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["textContent","flattenOptions","render","that","dom","options","_root","children","undefined","toString","isOptions","html","toRender","opts","_options","xml","xmlMode","text","elements","elems","root","ret","i","length","parseHTML","data","context","keepScripts","parsed","load","remove","contains","container","contained","next","parent","extract","map","merge","arr1","arr2","isArrayLike","newLength","len","item","Array","isArray"],"sources":["D:\\Map\\node_modules\\cheerio\\src\\static.ts"],"sourcesContent":["import type { BasicAcceptedElems } from './types.js';\nimport type { CheerioAPI } from './load.js';\nimport type { Cheerio } from './cheerio.js';\nimport type { AnyNode, Document } from 'domhandler';\nimport { textContent } from 'domutils';\nimport {\n  type InternalOptions,\n  type CheerioOptions,\n  flattenOptions as flattenOptions,\n} from './options.js';\nimport type { ExtractedMap, ExtractMap } from './api/extract.js';\n\n/**\n * Helper function to render a DOM.\n *\n * @param that - Cheerio instance to render.\n * @param dom - The DOM to render. Defaults to `that`'s root.\n * @param options - Options for rendering.\n * @returns The rendered document.\n */\nfunction render(\n  that: CheerioAPI,\n  dom: BasicAcceptedElems<AnyNode> | undefined,\n  options: InternalOptions,\n): string {\n  if (!that) return '';\n\n  return that(dom ?? that._root.children, null, undefined, options).toString();\n}\n\n/**\n * Checks if a passed object is an options object.\n *\n * @param dom - Object to check if it is an options object.\n * @param options - Options object.\n * @returns Whether the object is an options object.\n */\nfunction isOptions(\n  dom?: BasicAcceptedElems<AnyNode> | CheerioOptions | null,\n  options?: CheerioOptions,\n): dom is CheerioOptions {\n  return (\n    !options &&\n    typeof dom === 'object' &&\n    dom != null &&\n    !('length' in dom) &&\n    !('type' in dom)\n  );\n}\n\n/**\n * Renders the document.\n *\n * @category Static\n * @param options - Options for the renderer.\n * @returns The rendered document.\n */\nexport function html(this: CheerioAPI, options?: CheerioOptions): string;\n/**\n * Renders the document.\n *\n * @category Static\n * @param dom - Element to render.\n * @param options - Options for the renderer.\n * @returns The rendered document.\n */\nexport function html(\n  this: CheerioAPI,\n  dom?: BasicAcceptedElems<AnyNode>,\n  options?: CheerioOptions,\n): string;\nexport function html(\n  this: CheerioAPI,\n  dom?: BasicAcceptedElems<AnyNode> | CheerioOptions,\n  options?: CheerioOptions,\n): string {\n  /*\n   * Be flexible about parameters, sometimes we call html(),\n   * with options as only parameter\n   * check dom argument for dom element specific properties\n   * assume there is no 'length' or 'type' properties in the options object\n   */\n  const toRender = isOptions(dom) ? ((options = dom), undefined) : dom;\n\n  /*\n   * Sometimes `$.html()` is used without preloading html,\n   * so fallback non-existing options to the default ones.\n   */\n  const opts = {\n    ...this?._options,\n    ...flattenOptions(options),\n  };\n\n  return render(this, toRender, opts);\n}\n\n/**\n * Render the document as XML.\n *\n * @category Static\n * @param dom - Element to render.\n * @returns THe rendered document.\n */\nexport function xml(\n  this: CheerioAPI,\n  dom?: BasicAcceptedElems<AnyNode>,\n): string {\n  const options = { ...this._options, xmlMode: true };\n\n  return render(this, dom, options);\n}\n\n/**\n * Render the document as text.\n *\n * This returns the `textContent` of the passed elements. The result will\n * include the contents of `<script>` and `<style>` elements. To avoid this, use\n * `.prop('innerText')` instead.\n *\n * @category Static\n * @param elements - Elements to render.\n * @returns The rendered document.\n */\nexport function text(\n  this: CheerioAPI | void,\n  elements?: ArrayLike<AnyNode>,\n): string {\n  const elems = elements ?? (this ? this.root() : []);\n\n  let ret = '';\n\n  for (let i = 0; i < elems.length; i++) {\n    ret += textContent(elems[i]);\n  }\n\n  return ret;\n}\n\n/**\n * Parses a string into an array of DOM nodes. The `context` argument has no\n * meaning for Cheerio, but it is maintained for API compatibility with jQuery.\n *\n * @category Static\n * @param data - Markup that will be parsed.\n * @param context - Will be ignored. If it is a boolean it will be used as the\n *   value of `keepScripts`.\n * @param keepScripts - If false all scripts will be removed.\n * @returns The parsed DOM.\n * @alias Cheerio.parseHTML\n * @see {@link https://api.jquery.com/jQuery.parseHTML/}\n */\nexport function parseHTML(\n  this: CheerioAPI,\n  data: string,\n  context?: unknown,\n  keepScripts?: boolean,\n): AnyNode[];\nexport function parseHTML(this: CheerioAPI, data?: '' | null): null;\nexport function parseHTML(\n  this: CheerioAPI,\n  data?: string | null,\n  context?: unknown,\n  keepScripts = typeof context === 'boolean' ? context : false,\n): AnyNode[] | null {\n  if (!data || typeof data !== 'string') {\n    return null;\n  }\n\n  if (typeof context === 'boolean') {\n    keepScripts = context;\n  }\n\n  const parsed = this.load(data, this._options, false);\n  if (!keepScripts) {\n    parsed('script').remove();\n  }\n\n  /*\n   * The `children` array is used by Cheerio internally to group elements that\n   * share the same parents. When nodes created through `parseHTML` are\n   * inserted into previously-existing DOM structures, they will be removed\n   * from the `children` array. The results of `parseHTML` should remain\n   * constant across these operations, so a shallow copy should be returned.\n   */\n  return [...parsed.root()[0].children];\n}\n\n/**\n * Sometimes you need to work with the top-level root element. To query it, you\n * can use `$.root()`.\n *\n * @category Static\n * @example\n *\n * ```js\n * $.root().append('<ul id=\"vegetables\"></ul>').html();\n * //=> <ul id=\"fruits\">...</ul><ul id=\"vegetables\"></ul>\n * ```\n *\n * @returns Cheerio instance wrapping the root node.\n * @alias Cheerio.root\n */\nexport function root(this: CheerioAPI): Cheerio<Document> {\n  return this(this._root);\n}\n\n/**\n * Checks to see if the `contained` DOM element is a descendant of the\n * `container` DOM element.\n *\n * @category Static\n * @param container - Potential parent node.\n * @param contained - Potential child node.\n * @returns Indicates if the nodes contain one another.\n * @alias Cheerio.contains\n * @see {@link https://api.jquery.com/jQuery.contains/}\n */\nexport function contains(container: AnyNode, contained: AnyNode): boolean {\n  // According to the jQuery API, an element does not \"contain\" itself\n  if (contained === container) {\n    return false;\n  }\n\n  /*\n   * Step up the descendants, stopping when the root element is reached\n   * (signaled by `.parent` returning a reference to the same object)\n   */\n  let next: AnyNode | null = contained;\n  while (next && next !== next.parent) {\n    next = next.parent;\n    if (next === container) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Extract multiple values from a document, and store them in an object.\n *\n * @category Static\n * @param map - An object containing key-value pairs. The keys are the names of\n *   the properties to be created on the object, and the values are the\n *   selectors to be used to extract the values.\n * @returns An object containing the extracted values.\n */\nexport function extract<M extends ExtractMap>(\n  this: CheerioAPI,\n  map: M,\n): ExtractedMap<M> {\n  return this.root().extract(map);\n}\n\ntype Writable<T> = { -readonly [P in keyof T]: T[P] };\n\n/**\n * $.merge().\n *\n * @category Static\n * @param arr1 - First array.\n * @param arr2 - Second array.\n * @returns `arr1`, with elements of `arr2` inserted.\n * @alias Cheerio.merge\n * @see {@link https://api.jquery.com/jQuery.merge/}\n */\nexport function merge<T>(\n  arr1: Writable<ArrayLike<T>>,\n  arr2: ArrayLike<T>,\n): ArrayLike<T> | undefined {\n  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {\n    return;\n  }\n  let newLength = arr1.length;\n  const len = +arr2.length;\n\n  for (let i = 0; i < len; i++) {\n    arr1[newLength++] = arr2[i];\n  }\n  arr1.length = newLength;\n  return arr1;\n}\n\n/**\n * Checks if an object is array-like.\n *\n * @category Static\n * @param item - Item to check.\n * @returns Indicates if the item is array-like.\n */\nfunction isArrayLike(item: unknown): item is ArrayLike<unknown> {\n  if (Array.isArray(item)) {\n    return true;\n  }\n\n  if (\n    typeof item !== 'object' ||\n    item === null ||\n    !('length' in item) ||\n    typeof item.length !== 'number' ||\n    item.length < 0\n  ) {\n    return false;\n  }\n\n  for (let i = 0; i < item.length; i++) {\n    if (!(i in item)) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}