{"ast":null,"code":"import { EntityDecoder, DecodingMode, htmlDecodeTree, xmlDecodeTree } from \"entities/decode\";\nvar CharCodes;\n(function (CharCodes) {\n  CharCodes[CharCodes[\"Tab\"] = 9] = \"Tab\";\n  CharCodes[CharCodes[\"NewLine\"] = 10] = \"NewLine\";\n  CharCodes[CharCodes[\"FormFeed\"] = 12] = \"FormFeed\";\n  CharCodes[CharCodes[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n  CharCodes[CharCodes[\"Space\"] = 32] = \"Space\";\n  CharCodes[CharCodes[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n  CharCodes[CharCodes[\"Number\"] = 35] = \"Number\";\n  CharCodes[CharCodes[\"Amp\"] = 38] = \"Amp\";\n  CharCodes[CharCodes[\"SingleQuote\"] = 39] = \"SingleQuote\";\n  CharCodes[CharCodes[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n  CharCodes[CharCodes[\"Dash\"] = 45] = \"Dash\";\n  CharCodes[CharCodes[\"Slash\"] = 47] = \"Slash\";\n  CharCodes[CharCodes[\"Zero\"] = 48] = \"Zero\";\n  CharCodes[CharCodes[\"Nine\"] = 57] = \"Nine\";\n  CharCodes[CharCodes[\"Semi\"] = 59] = \"Semi\";\n  CharCodes[CharCodes[\"Lt\"] = 60] = \"Lt\";\n  CharCodes[CharCodes[\"Eq\"] = 61] = \"Eq\";\n  CharCodes[CharCodes[\"Gt\"] = 62] = \"Gt\";\n  CharCodes[CharCodes[\"Questionmark\"] = 63] = \"Questionmark\";\n  CharCodes[CharCodes[\"UpperA\"] = 65] = \"UpperA\";\n  CharCodes[CharCodes[\"LowerA\"] = 97] = \"LowerA\";\n  CharCodes[CharCodes[\"UpperF\"] = 70] = \"UpperF\";\n  CharCodes[CharCodes[\"LowerF\"] = 102] = \"LowerF\";\n  CharCodes[CharCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n  CharCodes[CharCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n  CharCodes[CharCodes[\"LowerX\"] = 120] = \"LowerX\";\n  CharCodes[CharCodes[\"OpeningSquareBracket\"] = 91] = \"OpeningSquareBracket\";\n})(CharCodes || (CharCodes = {}));\n/** All the states the tokenizer can be in. */\nvar State;\n(function (State) {\n  State[State[\"Text\"] = 1] = \"Text\";\n  State[State[\"BeforeTagName\"] = 2] = \"BeforeTagName\";\n  State[State[\"InTagName\"] = 3] = \"InTagName\";\n  State[State[\"InSelfClosingTag\"] = 4] = \"InSelfClosingTag\";\n  State[State[\"BeforeClosingTagName\"] = 5] = \"BeforeClosingTagName\";\n  State[State[\"InClosingTagName\"] = 6] = \"InClosingTagName\";\n  State[State[\"AfterClosingTagName\"] = 7] = \"AfterClosingTagName\";\n  // Attributes\n  State[State[\"BeforeAttributeName\"] = 8] = \"BeforeAttributeName\";\n  State[State[\"InAttributeName\"] = 9] = \"InAttributeName\";\n  State[State[\"AfterAttributeName\"] = 10] = \"AfterAttributeName\";\n  State[State[\"BeforeAttributeValue\"] = 11] = \"BeforeAttributeValue\";\n  State[State[\"InAttributeValueDq\"] = 12] = \"InAttributeValueDq\";\n  State[State[\"InAttributeValueSq\"] = 13] = \"InAttributeValueSq\";\n  State[State[\"InAttributeValueNq\"] = 14] = \"InAttributeValueNq\";\n  // Declarations\n  State[State[\"BeforeDeclaration\"] = 15] = \"BeforeDeclaration\";\n  State[State[\"InDeclaration\"] = 16] = \"InDeclaration\";\n  // Processing instructions\n  State[State[\"InProcessingInstruction\"] = 17] = \"InProcessingInstruction\";\n  // Comments & CDATA\n  State[State[\"BeforeComment\"] = 18] = \"BeforeComment\";\n  State[State[\"CDATASequence\"] = 19] = \"CDATASequence\";\n  State[State[\"InSpecialComment\"] = 20] = \"InSpecialComment\";\n  State[State[\"InCommentLike\"] = 21] = \"InCommentLike\";\n  // Special tags\n  State[State[\"BeforeSpecialS\"] = 22] = \"BeforeSpecialS\";\n  State[State[\"BeforeSpecialT\"] = 23] = \"BeforeSpecialT\";\n  State[State[\"SpecialStartSequence\"] = 24] = \"SpecialStartSequence\";\n  State[State[\"InSpecialTag\"] = 25] = \"InSpecialTag\";\n  State[State[\"InEntity\"] = 26] = \"InEntity\";\n})(State || (State = {}));\nfunction isWhitespace(c) {\n  return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;\n}\nfunction isEndOfTagSection(c) {\n  return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\nfunction isASCIIAlpha(c) {\n  return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;\n}\nexport var QuoteType;\n(function (QuoteType) {\n  QuoteType[QuoteType[\"NoValue\"] = 0] = \"NoValue\";\n  QuoteType[QuoteType[\"Unquoted\"] = 1] = \"Unquoted\";\n  QuoteType[QuoteType[\"Single\"] = 2] = \"Single\";\n  QuoteType[QuoteType[\"Double\"] = 3] = \"Double\";\n})(QuoteType || (QuoteType = {}));\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nconst Sequences = {\n  Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),\n  // CDATA[\n  CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),\n  // ]]>\n  CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),\n  // `-->`\n  ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),\n  // `</script`\n  StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),\n  // `</style`\n  TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]),\n  // `</title`\n  TextareaEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61]),\n  // `</textarea`\n  XmpEnd: new Uint8Array([0x3c, 0x2f, 0x78, 0x6d, 0x70]) // `</xmp`\n};\nexport default class Tokenizer {\n  constructor({\n    xmlMode = false,\n    decodeEntities = true\n  }, cbs) {\n    this.cbs = cbs;\n    /** The current state the tokenizer is in. */\n    this.state = State.Text;\n    /** The read buffer. */\n    this.buffer = \"\";\n    /** The beginning of the section that is currently being read. */\n    this.sectionStart = 0;\n    /** The index within the buffer that we are currently looking at. */\n    this.index = 0;\n    /** The start of the last entity. */\n    this.entityStart = 0;\n    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n    this.baseState = State.Text;\n    /** For special parsing behavior inside of script and style tags. */\n    this.isSpecial = false;\n    /** Indicates whether the tokenizer has been paused. */\n    this.running = true;\n    /** The offset of the current buffer. */\n    this.offset = 0;\n    this.currentSequence = undefined;\n    this.sequenceIndex = 0;\n    this.xmlMode = xmlMode;\n    this.decodeEntities = decodeEntities;\n    this.entityDecoder = new EntityDecoder(xmlMode ? xmlDecodeTree : htmlDecodeTree, (cp, consumed) => this.emitCodePoint(cp, consumed));\n  }\n  reset() {\n    this.state = State.Text;\n    this.buffer = \"\";\n    this.sectionStart = 0;\n    this.index = 0;\n    this.baseState = State.Text;\n    this.currentSequence = undefined;\n    this.running = true;\n    this.offset = 0;\n  }\n  write(chunk) {\n    this.offset += this.buffer.length;\n    this.buffer = chunk;\n    this.parse();\n  }\n  end() {\n    if (this.running) this.finish();\n  }\n  pause() {\n    this.running = false;\n  }\n  resume() {\n    this.running = true;\n    if (this.index < this.buffer.length + this.offset) {\n      this.parse();\n    }\n  }\n  stateText(c) {\n    if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {\n      if (this.index > this.sectionStart) {\n        this.cbs.ontext(this.sectionStart, this.index);\n      }\n      this.state = State.BeforeTagName;\n      this.sectionStart = this.index;\n    } else if (this.decodeEntities && c === CharCodes.Amp) {\n      this.startEntity();\n    }\n  }\n  stateSpecialStartSequence(c) {\n    const isEnd = this.sequenceIndex === this.currentSequence.length;\n    const isMatch = isEnd ?\n    // If we are at the end of the sequence, make sure the tag name has ended\n    isEndOfTagSection(c) :\n    // Otherwise, do a case-insensitive comparison\n    (c | 0x20) === this.currentSequence[this.sequenceIndex];\n    if (!isMatch) {\n      this.isSpecial = false;\n    } else if (!isEnd) {\n      this.sequenceIndex++;\n      return;\n    }\n    this.sequenceIndex = 0;\n    this.state = State.InTagName;\n    this.stateInTagName(c);\n  }\n  /** Look for an end tag. For <title> tags, also decode entities. */\n  stateInSpecialTag(c) {\n    if (this.sequenceIndex === this.currentSequence.length) {\n      if (c === CharCodes.Gt || isWhitespace(c)) {\n        const endOfText = this.index - this.currentSequence.length;\n        if (this.sectionStart < endOfText) {\n          // Spoof the index so that reported locations match up.\n          const actualIndex = this.index;\n          this.index = endOfText;\n          this.cbs.ontext(this.sectionStart, endOfText);\n          this.index = actualIndex;\n        }\n        this.isSpecial = false;\n        this.sectionStart = endOfText + 2; // Skip over the `</`\n        this.stateInClosingTagName(c);\n        return; // We are done; skip the rest of the function.\n      }\n      this.sequenceIndex = 0;\n    }\n    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n      this.sequenceIndex += 1;\n    } else if (this.sequenceIndex === 0) {\n      if (this.currentSequence === Sequences.TitleEnd) {\n        // We have to parse entities in <title> tags.\n        if (this.decodeEntities && c === CharCodes.Amp) {\n          this.startEntity();\n        }\n      } else if (this.fastForwardTo(CharCodes.Lt)) {\n        // Outside of <title> tags, we can fast-forward.\n        this.sequenceIndex = 1;\n      }\n    } else {\n      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n      this.sequenceIndex = Number(c === CharCodes.Lt);\n    }\n  }\n  stateCDATASequence(c) {\n    if (c === Sequences.Cdata[this.sequenceIndex]) {\n      if (++this.sequenceIndex === Sequences.Cdata.length) {\n        this.state = State.InCommentLike;\n        this.currentSequence = Sequences.CdataEnd;\n        this.sequenceIndex = 0;\n        this.sectionStart = this.index + 1;\n      }\n    } else {\n      this.sequenceIndex = 0;\n      this.state = State.InDeclaration;\n      this.stateInDeclaration(c); // Reconsume the character\n    }\n  }\n  /**\n   * When we wait for one specific character, we can speed things up\n   * by skipping through the buffer until we find it.\n   *\n   * @returns Whether the character was found.\n   */\n  fastForwardTo(c) {\n    while (++this.index < this.buffer.length + this.offset) {\n      if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n        return true;\n      }\n    }\n    /*\n     * We increment the index at the end of the `parse` loop,\n     * so set it to `buffer.length - 1` here.\n     *\n     * TODO: Refactor `parse` to increment index before calling states.\n     */\n    this.index = this.buffer.length + this.offset - 1;\n    return false;\n  }\n  /**\n   * Comments and CDATA end with `-->` and `]]>`.\n   *\n   * Their common qualities are:\n   * - Their end sequences have a distinct character they start with.\n   * - That character is then repeated, so we have to check multiple repeats.\n   * - All characters but the start character of the sequence can be skipped.\n   */\n  stateInCommentLike(c) {\n    if (c === this.currentSequence[this.sequenceIndex]) {\n      if (++this.sequenceIndex === this.currentSequence.length) {\n        if (this.currentSequence === Sequences.CdataEnd) {\n          this.cbs.oncdata(this.sectionStart, this.index, 2);\n        } else {\n          this.cbs.oncomment(this.sectionStart, this.index, 2);\n        }\n        this.sequenceIndex = 0;\n        this.sectionStart = this.index + 1;\n        this.state = State.Text;\n      }\n    } else if (this.sequenceIndex === 0) {\n      // Fast-forward to the first character of the sequence\n      if (this.fastForwardTo(this.currentSequence[0])) {\n        this.sequenceIndex = 1;\n      }\n    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n      // Allow long sequences, eg. --->, ]]]>\n      this.sequenceIndex = 0;\n    }\n  }\n  /**\n   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n   *\n   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n   * We allow anything that wouldn't end the tag.\n   */\n  isTagStartChar(c) {\n    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n  }\n  startSpecial(sequence, offset) {\n    this.isSpecial = true;\n    this.currentSequence = sequence;\n    this.sequenceIndex = offset;\n    this.state = State.SpecialStartSequence;\n  }\n  stateBeforeTagName(c) {\n    if (c === CharCodes.ExclamationMark) {\n      this.state = State.BeforeDeclaration;\n      this.sectionStart = this.index + 1;\n    } else if (c === CharCodes.Questionmark) {\n      this.state = State.InProcessingInstruction;\n      this.sectionStart = this.index + 1;\n    } else if (this.isTagStartChar(c)) {\n      const lower = c | 0x20;\n      this.sectionStart = this.index;\n      if (this.xmlMode) {\n        this.state = State.InTagName;\n      } else if (lower === Sequences.ScriptEnd[2]) {\n        this.state = State.BeforeSpecialS;\n      } else if (lower === Sequences.TitleEnd[2] || lower === Sequences.XmpEnd[2]) {\n        this.state = State.BeforeSpecialT;\n      } else {\n        this.state = State.InTagName;\n      }\n    } else if (c === CharCodes.Slash) {\n      this.state = State.BeforeClosingTagName;\n    } else {\n      this.state = State.Text;\n      this.stateText(c);\n    }\n  }\n  stateInTagName(c) {\n    if (isEndOfTagSection(c)) {\n      this.cbs.onopentagname(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    }\n  }\n  stateBeforeClosingTagName(c) {\n    if (isWhitespace(c)) {\n      // Ignore\n    } else if (c === CharCodes.Gt) {\n      this.state = State.Text;\n    } else {\n      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;\n      this.sectionStart = this.index;\n    }\n  }\n  stateInClosingTagName(c) {\n    if (c === CharCodes.Gt || isWhitespace(c)) {\n      this.cbs.onclosetag(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.state = State.AfterClosingTagName;\n      this.stateAfterClosingTagName(c);\n    }\n  }\n  stateAfterClosingTagName(c) {\n    // Skip everything until \">\"\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateBeforeAttributeName(c) {\n    if (c === CharCodes.Gt) {\n      this.cbs.onopentagend(this.index);\n      if (this.isSpecial) {\n        this.state = State.InSpecialTag;\n        this.sequenceIndex = 0;\n      } else {\n        this.state = State.Text;\n      }\n      this.sectionStart = this.index + 1;\n    } else if (c === CharCodes.Slash) {\n      this.state = State.InSelfClosingTag;\n    } else if (!isWhitespace(c)) {\n      this.state = State.InAttributeName;\n      this.sectionStart = this.index;\n    }\n  }\n  stateInSelfClosingTag(c) {\n    if (c === CharCodes.Gt) {\n      this.cbs.onselfclosingtag(this.index);\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n      this.isSpecial = false; // Reset special state, in case of self-closing special tags\n    } else if (!isWhitespace(c)) {\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    }\n  }\n  stateInAttributeName(c) {\n    if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n      this.cbs.onattribname(this.sectionStart, this.index);\n      this.sectionStart = this.index;\n      this.state = State.AfterAttributeName;\n      this.stateAfterAttributeName(c);\n    }\n  }\n  stateAfterAttributeName(c) {\n    if (c === CharCodes.Eq) {\n      this.state = State.BeforeAttributeValue;\n    } else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n      this.sectionStart = -1;\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    } else if (!isWhitespace(c)) {\n      this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n      this.state = State.InAttributeName;\n      this.sectionStart = this.index;\n    }\n  }\n  stateBeforeAttributeValue(c) {\n    if (c === CharCodes.DoubleQuote) {\n      this.state = State.InAttributeValueDq;\n      this.sectionStart = this.index + 1;\n    } else if (c === CharCodes.SingleQuote) {\n      this.state = State.InAttributeValueSq;\n      this.sectionStart = this.index + 1;\n    } else if (!isWhitespace(c)) {\n      this.sectionStart = this.index;\n      this.state = State.InAttributeValueNq;\n      this.stateInAttributeValueNoQuotes(c); // Reconsume token\n    }\n  }\n  handleInAttributeValue(c, quote) {\n    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {\n      this.cbs.onattribdata(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index + 1);\n      this.state = State.BeforeAttributeName;\n    } else if (this.decodeEntities && c === CharCodes.Amp) {\n      this.startEntity();\n    }\n  }\n  stateInAttributeValueDoubleQuotes(c) {\n    this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n  }\n  stateInAttributeValueSingleQuotes(c) {\n    this.handleInAttributeValue(c, CharCodes.SingleQuote);\n  }\n  stateInAttributeValueNoQuotes(c) {\n    if (isWhitespace(c) || c === CharCodes.Gt) {\n      this.cbs.onattribdata(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.cbs.onattribend(QuoteType.Unquoted, this.index);\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    } else if (this.decodeEntities && c === CharCodes.Amp) {\n      this.startEntity();\n    }\n  }\n  stateBeforeDeclaration(c) {\n    if (c === CharCodes.OpeningSquareBracket) {\n      this.state = State.CDATASequence;\n      this.sequenceIndex = 0;\n    } else {\n      this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;\n    }\n  }\n  stateInDeclaration(c) {\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.cbs.ondeclaration(this.sectionStart, this.index);\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateInProcessingInstruction(c) {\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateBeforeComment(c) {\n    if (c === CharCodes.Dash) {\n      this.state = State.InCommentLike;\n      this.currentSequence = Sequences.CommentEnd;\n      // Allow short comments (eg. <!-->)\n      this.sequenceIndex = 2;\n      this.sectionStart = this.index + 1;\n    } else {\n      this.state = State.InDeclaration;\n    }\n  }\n  stateInSpecialComment(c) {\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.cbs.oncomment(this.sectionStart, this.index, 0);\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n  stateBeforeSpecialS(c) {\n    const lower = c | 0x20;\n    if (lower === Sequences.ScriptEnd[3]) {\n      this.startSpecial(Sequences.ScriptEnd, 4);\n    } else if (lower === Sequences.StyleEnd[3]) {\n      this.startSpecial(Sequences.StyleEnd, 4);\n    } else {\n      this.state = State.InTagName;\n      this.stateInTagName(c); // Consume the token again\n    }\n  }\n  stateBeforeSpecialT(c) {\n    const lower = c | 0x20;\n    switch (lower) {\n      case Sequences.TitleEnd[3]:\n        {\n          this.startSpecial(Sequences.TitleEnd, 4);\n          break;\n        }\n      case Sequences.TextareaEnd[3]:\n        {\n          this.startSpecial(Sequences.TextareaEnd, 4);\n          break;\n        }\n      case Sequences.XmpEnd[3]:\n        {\n          this.startSpecial(Sequences.XmpEnd, 4);\n          break;\n        }\n      default:\n        {\n          this.state = State.InTagName;\n          this.stateInTagName(c); // Consume the token again\n        }\n    }\n  }\n  startEntity() {\n    this.baseState = this.state;\n    this.state = State.InEntity;\n    this.entityStart = this.index;\n    this.entityDecoder.startEntity(this.xmlMode ? DecodingMode.Strict : this.baseState === State.Text || this.baseState === State.InSpecialTag ? DecodingMode.Legacy : DecodingMode.Attribute);\n  }\n  stateInEntity() {\n    const length = this.entityDecoder.write(this.buffer, this.index - this.offset);\n    // If `length` is positive, we are done with the entity.\n    if (length >= 0) {\n      this.state = this.baseState;\n      if (length === 0) {\n        this.index = this.entityStart;\n      }\n    } else {\n      // Mark buffer as consumed.\n      this.index = this.offset + this.buffer.length - 1;\n    }\n  }\n  /**\n   * Remove data that has already been consumed from the buffer.\n   */\n  cleanup() {\n    // If we are inside of text or attributes, emit what we already have.\n    if (this.running && this.sectionStart !== this.index) {\n      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {\n        this.cbs.ontext(this.sectionStart, this.index);\n        this.sectionStart = this.index;\n      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {\n        this.cbs.onattribdata(this.sectionStart, this.index);\n        this.sectionStart = this.index;\n      }\n    }\n  }\n  shouldContinue() {\n    return this.index < this.buffer.length + this.offset && this.running;\n  }\n  /**\n   * Iterates through the buffer, calling the function corresponding to the current state.\n   *\n   * States that are more likely to be hit are higher up, as a performance improvement.\n   */\n  parse() {\n    while (this.shouldContinue()) {\n      const c = this.buffer.charCodeAt(this.index - this.offset);\n      switch (this.state) {\n        case State.Text:\n          {\n            this.stateText(c);\n            break;\n          }\n        case State.SpecialStartSequence:\n          {\n            this.stateSpecialStartSequence(c);\n            break;\n          }\n        case State.InSpecialTag:\n          {\n            this.stateInSpecialTag(c);\n            break;\n          }\n        case State.CDATASequence:\n          {\n            this.stateCDATASequence(c);\n            break;\n          }\n        case State.InAttributeValueDq:\n          {\n            this.stateInAttributeValueDoubleQuotes(c);\n            break;\n          }\n        case State.InAttributeName:\n          {\n            this.stateInAttributeName(c);\n            break;\n          }\n        case State.InCommentLike:\n          {\n            this.stateInCommentLike(c);\n            break;\n          }\n        case State.InSpecialComment:\n          {\n            this.stateInSpecialComment(c);\n            break;\n          }\n        case State.BeforeAttributeName:\n          {\n            this.stateBeforeAttributeName(c);\n            break;\n          }\n        case State.InTagName:\n          {\n            this.stateInTagName(c);\n            break;\n          }\n        case State.InClosingTagName:\n          {\n            this.stateInClosingTagName(c);\n            break;\n          }\n        case State.BeforeTagName:\n          {\n            this.stateBeforeTagName(c);\n            break;\n          }\n        case State.AfterAttributeName:\n          {\n            this.stateAfterAttributeName(c);\n            break;\n          }\n        case State.InAttributeValueSq:\n          {\n            this.stateInAttributeValueSingleQuotes(c);\n            break;\n          }\n        case State.BeforeAttributeValue:\n          {\n            this.stateBeforeAttributeValue(c);\n            break;\n          }\n        case State.BeforeClosingTagName:\n          {\n            this.stateBeforeClosingTagName(c);\n            break;\n          }\n        case State.AfterClosingTagName:\n          {\n            this.stateAfterClosingTagName(c);\n            break;\n          }\n        case State.BeforeSpecialS:\n          {\n            this.stateBeforeSpecialS(c);\n            break;\n          }\n        case State.BeforeSpecialT:\n          {\n            this.stateBeforeSpecialT(c);\n            break;\n          }\n        case State.InAttributeValueNq:\n          {\n            this.stateInAttributeValueNoQuotes(c);\n            break;\n          }\n        case State.InSelfClosingTag:\n          {\n            this.stateInSelfClosingTag(c);\n            break;\n          }\n        case State.InDeclaration:\n          {\n            this.stateInDeclaration(c);\n            break;\n          }\n        case State.BeforeDeclaration:\n          {\n            this.stateBeforeDeclaration(c);\n            break;\n          }\n        case State.BeforeComment:\n          {\n            this.stateBeforeComment(c);\n            break;\n          }\n        case State.InProcessingInstruction:\n          {\n            this.stateInProcessingInstruction(c);\n            break;\n          }\n        case State.InEntity:\n          {\n            this.stateInEntity();\n            break;\n          }\n      }\n      this.index++;\n    }\n    this.cleanup();\n  }\n  finish() {\n    if (this.state === State.InEntity) {\n      this.entityDecoder.end();\n      this.state = this.baseState;\n    }\n    this.handleTrailingData();\n    this.cbs.onend();\n  }\n  /** Handle any trailing data. */\n  handleTrailingData() {\n    const endIndex = this.buffer.length + this.offset;\n    // If there is no remaining data, we are done.\n    if (this.sectionStart >= endIndex) {\n      return;\n    }\n    if (this.state === State.InCommentLike) {\n      if (this.currentSequence === Sequences.CdataEnd) {\n        this.cbs.oncdata(this.sectionStart, endIndex, 0);\n      } else {\n        this.cbs.oncomment(this.sectionStart, endIndex, 0);\n      }\n    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {\n      /*\n       * If we are currently in an opening or closing tag, us not calling the\n       * respective callback signals that the tag should be ignored.\n       */\n    } else {\n      this.cbs.ontext(this.sectionStart, endIndex);\n    }\n  }\n  emitCodePoint(cp, consumed) {\n    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {\n      if (this.sectionStart < this.entityStart) {\n        this.cbs.onattribdata(this.sectionStart, this.entityStart);\n      }\n      this.sectionStart = this.entityStart + consumed;\n      this.index = this.sectionStart - 1;\n      this.cbs.onattribentity(cp);\n    } else {\n      if (this.sectionStart < this.entityStart) {\n        this.cbs.ontext(this.sectionStart, this.entityStart);\n      }\n      this.sectionStart = this.entityStart + consumed;\n      this.index = this.sectionStart - 1;\n      this.cbs.ontextentity(cp, this.sectionStart);\n    }\n  }\n}","map":{"version":3,"names":["EntityDecoder","DecodingMode","htmlDecodeTree","xmlDecodeTree","CharCodes","State","isWhitespace","c","Space","NewLine","Tab","FormFeed","CarriageReturn","isEndOfTagSection","Slash","Gt","isASCIIAlpha","LowerA","LowerZ","UpperA","UpperZ","QuoteType","Sequences","Cdata","Uint8Array","CdataEnd","CommentEnd","ScriptEnd","StyleEnd","TitleEnd","TextareaEnd","XmpEnd","Tokenizer","constructor","xmlMode","decodeEntities","cbs","state","Text","buffer","sectionStart","index","entityStart","baseState","isSpecial","running","offset","currentSequence","undefined","sequenceIndex","entityDecoder","cp","consumed","emitCodePoint","reset","write","chunk","length","parse","end","finish","pause","resume","stateText","Lt","fastForwardTo","ontext","BeforeTagName","Amp","startEntity","stateSpecialStartSequence","isEnd","isMatch","InTagName","stateInTagName","stateInSpecialTag","endOfText","actualIndex","stateInClosingTagName","Number","stateCDATASequence","InCommentLike","InDeclaration","stateInDeclaration","charCodeAt","stateInCommentLike","oncdata","oncomment","isTagStartChar","startSpecial","sequence","SpecialStartSequence","stateBeforeTagName","ExclamationMark","BeforeDeclaration","Questionmark","InProcessingInstruction","lower","BeforeSpecialS","BeforeSpecialT","BeforeClosingTagName","onopentagname","BeforeAttributeName","stateBeforeAttributeName","stateBeforeClosingTagName","InClosingTagName","InSpecialComment","onclosetag","AfterClosingTagName","stateAfterClosingTagName","onopentagend","InSpecialTag","InSelfClosingTag","InAttributeName","stateInSelfClosingTag","onselfclosingtag","stateInAttributeName","Eq","onattribname","AfterAttributeName","stateAfterAttributeName","BeforeAttributeValue","onattribend","NoValue","stateBeforeAttributeValue","DoubleQuote","InAttributeValueDq","SingleQuote","InAttributeValueSq","InAttributeValueNq","stateInAttributeValueNoQuotes","handleInAttributeValue","quote","onattribdata","Double","Single","stateInAttributeValueDoubleQuotes","stateInAttributeValueSingleQuotes","Unquoted","stateBeforeDeclaration","OpeningSquareBracket","CDATASequence","Dash","BeforeComment","ondeclaration","stateInProcessingInstruction","onprocessinginstruction","stateBeforeComment","stateInSpecialComment","stateBeforeSpecialS","stateBeforeSpecialT","InEntity","Strict","Legacy","Attribute","stateInEntity","cleanup","shouldContinue","handleTrailingData","onend","endIndex","onattribentity","ontextentity"],"sources":["D:\\Map\\node_modules\\htmlparser2\\src\\Tokenizer.ts"],"sourcesContent":["import {\n    EntityDecoder,\n    DecodingMode,\n    htmlDecodeTree,\n    xmlDecodeTree,\n} from \"entities/decode\";\n\nconst enum CharCodes {\n    Tab = 0x9, // \"\\t\"\n    NewLine = 0xa, // \"\\n\"\n    FormFeed = 0xc, // \"\\f\"\n    CarriageReturn = 0xd, // \"\\r\"\n    Space = 0x20, // \" \"\n    ExclamationMark = 0x21, // \"!\"\n    Number = 0x23, // \"#\"\n    Amp = 0x26, // \"&\"\n    SingleQuote = 0x27, // \"'\"\n    DoubleQuote = 0x22, // '\"'\n    Dash = 0x2d, // \"-\"\n    Slash = 0x2f, // \"/\"\n    Zero = 0x30, // \"0\"\n    Nine = 0x39, // \"9\"\n    Semi = 0x3b, // \";\"\n    Lt = 0x3c, // \"<\"\n    Eq = 0x3d, // \"=\"\n    Gt = 0x3e, // \">\"\n    Questionmark = 0x3f, // \"?\"\n    UpperA = 0x41, // \"A\"\n    LowerA = 0x61, // \"a\"\n    UpperF = 0x46, // \"F\"\n    LowerF = 0x66, // \"f\"\n    UpperZ = 0x5a, // \"Z\"\n    LowerZ = 0x7a, // \"z\"\n    LowerX = 0x78, // \"x\"\n    OpeningSquareBracket = 0x5b, // \"[\"\n}\n\n/** All the states the tokenizer can be in. */\nconst enum State {\n    Text = 1,\n    BeforeTagName, // After <\n    InTagName,\n    InSelfClosingTag,\n    BeforeClosingTagName,\n    InClosingTagName,\n    AfterClosingTagName,\n\n    // Attributes\n    BeforeAttributeName,\n    InAttributeName,\n    AfterAttributeName,\n    BeforeAttributeValue,\n    InAttributeValueDq, // \"\n    InAttributeValueSq, // '\n    InAttributeValueNq,\n\n    // Declarations\n    BeforeDeclaration, // !\n    InDeclaration,\n\n    // Processing instructions\n    InProcessingInstruction, // ?\n\n    // Comments & CDATA\n    BeforeComment,\n    CDATASequence,\n    InSpecialComment,\n    InCommentLike,\n\n    // Special tags\n    BeforeSpecialS, // Decide if we deal with `<script` or `<style`\n    BeforeSpecialT, // Decide if we deal with `<title` or `<textarea`\n    SpecialStartSequence,\n    InSpecialTag,\n\n    InEntity,\n}\n\nfunction isWhitespace(c: number): boolean {\n    return (\n        c === CharCodes.Space ||\n        c === CharCodes.NewLine ||\n        c === CharCodes.Tab ||\n        c === CharCodes.FormFeed ||\n        c === CharCodes.CarriageReturn\n    );\n}\n\nfunction isEndOfTagSection(c: number): boolean {\n    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\n\nfunction isASCIIAlpha(c: number): boolean {\n    return (\n        (c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||\n        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ)\n    );\n}\n\nexport enum QuoteType {\n    NoValue = 0,\n    Unquoted = 1,\n    Single = 2,\n    Double = 3,\n}\n\nexport interface Callbacks {\n    onattribdata(start: number, endIndex: number): void;\n    onattribentity(codepoint: number): void;\n    onattribend(quote: QuoteType, endIndex: number): void;\n    onattribname(start: number, endIndex: number): void;\n    oncdata(start: number, endIndex: number, endOffset: number): void;\n    onclosetag(start: number, endIndex: number): void;\n    oncomment(start: number, endIndex: number, endOffset: number): void;\n    ondeclaration(start: number, endIndex: number): void;\n    onend(): void;\n    onopentagend(endIndex: number): void;\n    onopentagname(start: number, endIndex: number): void;\n    onprocessinginstruction(start: number, endIndex: number): void;\n    onselfclosingtag(endIndex: number): void;\n    ontext(start: number, endIndex: number): void;\n    ontextentity(codepoint: number, endIndex: number): void;\n}\n\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nconst Sequences = {\n    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]), // CDATA[\n    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]), // ]]>\n    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]), // `-->`\n    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]), // `</script`\n    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]), // `</style`\n    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\n    TextareaEnd: new Uint8Array([\n        0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61,\n    ]), // `</textarea`\n    XmpEnd: new Uint8Array([0x3c, 0x2f, 0x78, 0x6d, 0x70]), // `</xmp`\n};\n\nexport default class Tokenizer {\n    /** The current state the tokenizer is in. */\n    private state = State.Text;\n    /** The read buffer. */\n    private buffer = \"\";\n    /** The beginning of the section that is currently being read. */\n    private sectionStart = 0;\n    /** The index within the buffer that we are currently looking at. */\n    private index = 0;\n    /** The start of the last entity. */\n    private entityStart = 0;\n    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n    private baseState = State.Text;\n    /** For special parsing behavior inside of script and style tags. */\n    private isSpecial = false;\n    /** Indicates whether the tokenizer has been paused. */\n    public running = true;\n    /** The offset of the current buffer. */\n    private offset = 0;\n\n    private readonly xmlMode: boolean;\n    private readonly decodeEntities: boolean;\n    private readonly entityDecoder: EntityDecoder;\n\n    constructor(\n        {\n            xmlMode = false,\n            decodeEntities = true,\n        }: { xmlMode?: boolean; decodeEntities?: boolean },\n        private readonly cbs: Callbacks,\n    ) {\n        this.xmlMode = xmlMode;\n        this.decodeEntities = decodeEntities;\n        this.entityDecoder = new EntityDecoder(\n            xmlMode ? xmlDecodeTree : htmlDecodeTree,\n            (cp, consumed) => this.emitCodePoint(cp, consumed),\n        );\n    }\n\n    public reset(): void {\n        this.state = State.Text;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this.index = 0;\n        this.baseState = State.Text;\n        this.currentSequence = undefined!;\n        this.running = true;\n        this.offset = 0;\n    }\n\n    public write(chunk: string): void {\n        this.offset += this.buffer.length;\n        this.buffer = chunk;\n        this.parse();\n    }\n\n    public end(): void {\n        if (this.running) this.finish();\n    }\n\n    public pause(): void {\n        this.running = false;\n    }\n\n    public resume(): void {\n        this.running = true;\n        if (this.index < this.buffer.length + this.offset) {\n            this.parse();\n        }\n    }\n\n    private stateText(c: number): void {\n        if (\n            c === CharCodes.Lt ||\n            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))\n        ) {\n            if (this.index > this.sectionStart) {\n                this.cbs.ontext(this.sectionStart, this.index);\n            }\n            this.state = State.BeforeTagName;\n            this.sectionStart = this.index;\n        } else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n\n    private currentSequence: Uint8Array = undefined!;\n    private sequenceIndex = 0;\n    private stateSpecialStartSequence(c: number): void {\n        const isEnd = this.sequenceIndex === this.currentSequence.length;\n        const isMatch = isEnd\n            ? // If we are at the end of the sequence, make sure the tag name has ended\n              isEndOfTagSection(c)\n            : // Otherwise, do a case-insensitive comparison\n              (c | 0x20) === this.currentSequence[this.sequenceIndex];\n\n        if (!isMatch) {\n            this.isSpecial = false;\n        } else if (!isEnd) {\n            this.sequenceIndex++;\n            return;\n        }\n\n        this.sequenceIndex = 0;\n        this.state = State.InTagName;\n        this.stateInTagName(c);\n    }\n\n    /** Look for an end tag. For <title> tags, also decode entities. */\n    private stateInSpecialTag(c: number): void {\n        if (this.sequenceIndex === this.currentSequence.length) {\n            if (c === CharCodes.Gt || isWhitespace(c)) {\n                const endOfText = this.index - this.currentSequence.length;\n\n                if (this.sectionStart < endOfText) {\n                    // Spoof the index so that reported locations match up.\n                    const actualIndex = this.index;\n                    this.index = endOfText;\n                    this.cbs.ontext(this.sectionStart, endOfText);\n                    this.index = actualIndex;\n                }\n\n                this.isSpecial = false;\n                this.sectionStart = endOfText + 2; // Skip over the `</`\n                this.stateInClosingTagName(c);\n                return; // We are done; skip the rest of the function.\n            }\n\n            this.sequenceIndex = 0;\n        }\n\n        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n            this.sequenceIndex += 1;\n        } else if (this.sequenceIndex === 0) {\n            if (this.currentSequence === Sequences.TitleEnd) {\n                // We have to parse entities in <title> tags.\n                if (this.decodeEntities && c === CharCodes.Amp) {\n                    this.startEntity();\n                }\n            } else if (this.fastForwardTo(CharCodes.Lt)) {\n                // Outside of <title> tags, we can fast-forward.\n                this.sequenceIndex = 1;\n            }\n        } else {\n            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n            this.sequenceIndex = Number(c === CharCodes.Lt);\n        }\n    }\n\n    private stateCDATASequence(c: number): void {\n        if (c === Sequences.Cdata[this.sequenceIndex]) {\n            if (++this.sequenceIndex === Sequences.Cdata.length) {\n                this.state = State.InCommentLike;\n                this.currentSequence = Sequences.CdataEnd;\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n            }\n        } else {\n            this.sequenceIndex = 0;\n            this.state = State.InDeclaration;\n            this.stateInDeclaration(c); // Reconsume the character\n        }\n    }\n\n    /**\n     * When we wait for one specific character, we can speed things up\n     * by skipping through the buffer until we find it.\n     *\n     * @returns Whether the character was found.\n     */\n    private fastForwardTo(c: number): boolean {\n        while (++this.index < this.buffer.length + this.offset) {\n            if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n                return true;\n            }\n        }\n\n        /*\n         * We increment the index at the end of the `parse` loop,\n         * so set it to `buffer.length - 1` here.\n         *\n         * TODO: Refactor `parse` to increment index before calling states.\n         */\n        this.index = this.buffer.length + this.offset - 1;\n\n        return false;\n    }\n\n    /**\n     * Comments and CDATA end with `-->` and `]]>`.\n     *\n     * Their common qualities are:\n     * - Their end sequences have a distinct character they start with.\n     * - That character is then repeated, so we have to check multiple repeats.\n     * - All characters but the start character of the sequence can be skipped.\n     */\n    private stateInCommentLike(c: number): void {\n        if (c === this.currentSequence[this.sequenceIndex]) {\n            if (++this.sequenceIndex === this.currentSequence.length) {\n                if (this.currentSequence === Sequences.CdataEnd) {\n                    this.cbs.oncdata(this.sectionStart, this.index, 2);\n                } else {\n                    this.cbs.oncomment(this.sectionStart, this.index, 2);\n                }\n\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n                this.state = State.Text;\n            }\n        } else if (this.sequenceIndex === 0) {\n            // Fast-forward to the first character of the sequence\n            if (this.fastForwardTo(this.currentSequence[0])) {\n                this.sequenceIndex = 1;\n            }\n        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n            // Allow long sequences, eg. --->, ]]]>\n            this.sequenceIndex = 0;\n        }\n    }\n\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    private isTagStartChar(c: number) {\n        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n    }\n\n    private startSpecial(sequence: Uint8Array, offset: number) {\n        this.isSpecial = true;\n        this.currentSequence = sequence;\n        this.sequenceIndex = offset;\n        this.state = State.SpecialStartSequence;\n    }\n\n    private stateBeforeTagName(c: number): void {\n        if (c === CharCodes.ExclamationMark) {\n            this.state = State.BeforeDeclaration;\n            this.sectionStart = this.index + 1;\n        } else if (c === CharCodes.Questionmark) {\n            this.state = State.InProcessingInstruction;\n            this.sectionStart = this.index + 1;\n        } else if (this.isTagStartChar(c)) {\n            const lower = c | 0x20;\n            this.sectionStart = this.index;\n            if (this.xmlMode) {\n                this.state = State.InTagName;\n            } else if (lower === Sequences.ScriptEnd[2]) {\n                this.state = State.BeforeSpecialS;\n            } else if (\n                lower === Sequences.TitleEnd[2] ||\n                lower === Sequences.XmpEnd[2]\n            ) {\n                this.state = State.BeforeSpecialT;\n            } else {\n                this.state = State.InTagName;\n            }\n        } else if (c === CharCodes.Slash) {\n            this.state = State.BeforeClosingTagName;\n        } else {\n            this.state = State.Text;\n            this.stateText(c);\n        }\n    }\n    private stateInTagName(c: number): void {\n        if (isEndOfTagSection(c)) {\n            this.cbs.onopentagname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    private stateBeforeClosingTagName(c: number): void {\n        if (isWhitespace(c)) {\n            // Ignore\n        } else if (c === CharCodes.Gt) {\n            this.state = State.Text;\n        } else {\n            this.state = this.isTagStartChar(c)\n                ? State.InClosingTagName\n                : State.InSpecialComment;\n            this.sectionStart = this.index;\n        }\n    }\n    private stateInClosingTagName(c: number): void {\n        if (c === CharCodes.Gt || isWhitespace(c)) {\n            this.cbs.onclosetag(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterClosingTagName;\n            this.stateAfterClosingTagName(c);\n        }\n    }\n    private stateAfterClosingTagName(c: number): void {\n        // Skip everything until \">\"\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    private stateBeforeAttributeName(c: number): void {\n        if (c === CharCodes.Gt) {\n            this.cbs.onopentagend(this.index);\n            if (this.isSpecial) {\n                this.state = State.InSpecialTag;\n                this.sequenceIndex = 0;\n            } else {\n                this.state = State.Text;\n            }\n            this.sectionStart = this.index + 1;\n        } else if (c === CharCodes.Slash) {\n            this.state = State.InSelfClosingTag;\n        } else if (!isWhitespace(c)) {\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    private stateInSelfClosingTag(c: number): void {\n        if (c === CharCodes.Gt) {\n            this.cbs.onselfclosingtag(this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n            this.isSpecial = false; // Reset special state, in case of self-closing special tags\n        } else if (!isWhitespace(c)) {\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    private stateInAttributeName(c: number): void {\n        if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n            this.cbs.onattribname(this.sectionStart, this.index);\n            this.sectionStart = this.index;\n            this.state = State.AfterAttributeName;\n            this.stateAfterAttributeName(c);\n        }\n    }\n    private stateAfterAttributeName(c: number): void {\n        if (c === CharCodes.Eq) {\n            this.state = State.BeforeAttributeValue;\n        } else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        } else if (!isWhitespace(c)) {\n            this.cbs.onattribend(QuoteType.NoValue, this.sectionStart);\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    private stateBeforeAttributeValue(c: number): void {\n        if (c === CharCodes.DoubleQuote) {\n            this.state = State.InAttributeValueDq;\n            this.sectionStart = this.index + 1;\n        } else if (c === CharCodes.SingleQuote) {\n            this.state = State.InAttributeValueSq;\n            this.sectionStart = this.index + 1;\n        } else if (!isWhitespace(c)) {\n            this.sectionStart = this.index;\n            this.state = State.InAttributeValueNq;\n            this.stateInAttributeValueNoQuotes(c); // Reconsume token\n        }\n    }\n    private handleInAttributeValue(c: number, quote: number) {\n        if (\n            c === quote ||\n            (!this.decodeEntities && this.fastForwardTo(quote))\n        ) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(\n                quote === CharCodes.DoubleQuote\n                    ? QuoteType.Double\n                    : QuoteType.Single,\n                this.index + 1,\n            );\n            this.state = State.BeforeAttributeName;\n        } else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    private stateInAttributeValueDoubleQuotes(c: number): void {\n        this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n    }\n    private stateInAttributeValueSingleQuotes(c: number): void {\n        this.handleInAttributeValue(c, CharCodes.SingleQuote);\n    }\n    private stateInAttributeValueNoQuotes(c: number): void {\n        if (isWhitespace(c) || c === CharCodes.Gt) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(QuoteType.Unquoted, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        } else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    }\n    private stateBeforeDeclaration(c: number): void {\n        if (c === CharCodes.OpeningSquareBracket) {\n            this.state = State.CDATASequence;\n            this.sequenceIndex = 0;\n        } else {\n            this.state =\n                c === CharCodes.Dash\n                    ? State.BeforeComment\n                    : State.InDeclaration;\n        }\n    }\n    private stateInDeclaration(c: number): void {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.ondeclaration(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    private stateInProcessingInstruction(c: number): void {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    private stateBeforeComment(c: number): void {\n        if (c === CharCodes.Dash) {\n            this.state = State.InCommentLike;\n            this.currentSequence = Sequences.CommentEnd;\n            // Allow short comments (eg. <!-->)\n            this.sequenceIndex = 2;\n            this.sectionStart = this.index + 1;\n        } else {\n            this.state = State.InDeclaration;\n        }\n    }\n    private stateInSpecialComment(c: number): void {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.oncomment(this.sectionStart, this.index, 0);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    private stateBeforeSpecialS(c: number): void {\n        const lower = c | 0x20;\n        if (lower === Sequences.ScriptEnd[3]) {\n            this.startSpecial(Sequences.ScriptEnd, 4);\n        } else if (lower === Sequences.StyleEnd[3]) {\n            this.startSpecial(Sequences.StyleEnd, 4);\n        } else {\n            this.state = State.InTagName;\n            this.stateInTagName(c); // Consume the token again\n        }\n    }\n\n    private stateBeforeSpecialT(c: number): void {\n        const lower = c | 0x20;\n        switch (lower) {\n            case Sequences.TitleEnd[3]: {\n                this.startSpecial(Sequences.TitleEnd, 4);\n\n                break;\n            }\n            case Sequences.TextareaEnd[3]: {\n                this.startSpecial(Sequences.TextareaEnd, 4);\n\n                break;\n            }\n            case Sequences.XmpEnd[3]: {\n                this.startSpecial(Sequences.XmpEnd, 4);\n\n                break;\n            }\n            default: {\n                this.state = State.InTagName;\n                this.stateInTagName(c); // Consume the token again\n            }\n        }\n    }\n\n    private startEntity() {\n        this.baseState = this.state;\n        this.state = State.InEntity;\n        this.entityStart = this.index;\n        this.entityDecoder.startEntity(\n            this.xmlMode\n                ? DecodingMode.Strict\n                : this.baseState === State.Text ||\n                    this.baseState === State.InSpecialTag\n                  ? DecodingMode.Legacy\n                  : DecodingMode.Attribute,\n        );\n    }\n\n    private stateInEntity(): void {\n        const length = this.entityDecoder.write(\n            this.buffer,\n            this.index - this.offset,\n        );\n\n        // If `length` is positive, we are done with the entity.\n        if (length >= 0) {\n            this.state = this.baseState;\n\n            if (length === 0) {\n                this.index = this.entityStart;\n            }\n        } else {\n            // Mark buffer as consumed.\n            this.index = this.offset + this.buffer.length - 1;\n        }\n    }\n\n    /**\n     * Remove data that has already been consumed from the buffer.\n     */\n    private cleanup() {\n        // If we are inside of text or attributes, emit what we already have.\n        if (this.running && this.sectionStart !== this.index) {\n            if (\n                this.state === State.Text ||\n                (this.state === State.InSpecialTag && this.sequenceIndex === 0)\n            ) {\n                this.cbs.ontext(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            } else if (\n                this.state === State.InAttributeValueDq ||\n                this.state === State.InAttributeValueSq ||\n                this.state === State.InAttributeValueNq\n            ) {\n                this.cbs.onattribdata(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n        }\n    }\n\n    private shouldContinue() {\n        return this.index < this.buffer.length + this.offset && this.running;\n    }\n\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    private parse() {\n        while (this.shouldContinue()) {\n            const c = this.buffer.charCodeAt(this.index - this.offset);\n            switch (this.state) {\n                case State.Text: {\n                    this.stateText(c);\n                    break;\n                }\n                case State.SpecialStartSequence: {\n                    this.stateSpecialStartSequence(c);\n                    break;\n                }\n                case State.InSpecialTag: {\n                    this.stateInSpecialTag(c);\n                    break;\n                }\n                case State.CDATASequence: {\n                    this.stateCDATASequence(c);\n                    break;\n                }\n                case State.InAttributeValueDq: {\n                    this.stateInAttributeValueDoubleQuotes(c);\n                    break;\n                }\n                case State.InAttributeName: {\n                    this.stateInAttributeName(c);\n                    break;\n                }\n                case State.InCommentLike: {\n                    this.stateInCommentLike(c);\n                    break;\n                }\n                case State.InSpecialComment: {\n                    this.stateInSpecialComment(c);\n                    break;\n                }\n                case State.BeforeAttributeName: {\n                    this.stateBeforeAttributeName(c);\n                    break;\n                }\n                case State.InTagName: {\n                    this.stateInTagName(c);\n                    break;\n                }\n                case State.InClosingTagName: {\n                    this.stateInClosingTagName(c);\n                    break;\n                }\n                case State.BeforeTagName: {\n                    this.stateBeforeTagName(c);\n                    break;\n                }\n                case State.AfterAttributeName: {\n                    this.stateAfterAttributeName(c);\n                    break;\n                }\n                case State.InAttributeValueSq: {\n                    this.stateInAttributeValueSingleQuotes(c);\n                    break;\n                }\n                case State.BeforeAttributeValue: {\n                    this.stateBeforeAttributeValue(c);\n                    break;\n                }\n                case State.BeforeClosingTagName: {\n                    this.stateBeforeClosingTagName(c);\n                    break;\n                }\n                case State.AfterClosingTagName: {\n                    this.stateAfterClosingTagName(c);\n                    break;\n                }\n                case State.BeforeSpecialS: {\n                    this.stateBeforeSpecialS(c);\n                    break;\n                }\n                case State.BeforeSpecialT: {\n                    this.stateBeforeSpecialT(c);\n                    break;\n                }\n                case State.InAttributeValueNq: {\n                    this.stateInAttributeValueNoQuotes(c);\n                    break;\n                }\n                case State.InSelfClosingTag: {\n                    this.stateInSelfClosingTag(c);\n                    break;\n                }\n                case State.InDeclaration: {\n                    this.stateInDeclaration(c);\n                    break;\n                }\n                case State.BeforeDeclaration: {\n                    this.stateBeforeDeclaration(c);\n                    break;\n                }\n                case State.BeforeComment: {\n                    this.stateBeforeComment(c);\n                    break;\n                }\n                case State.InProcessingInstruction: {\n                    this.stateInProcessingInstruction(c);\n                    break;\n                }\n                case State.InEntity: {\n                    this.stateInEntity();\n                    break;\n                }\n            }\n            this.index++;\n        }\n        this.cleanup();\n    }\n\n    private finish() {\n        if (this.state === State.InEntity) {\n            this.entityDecoder.end();\n            this.state = this.baseState;\n        }\n\n        this.handleTrailingData();\n\n        this.cbs.onend();\n    }\n\n    /** Handle any trailing data. */\n    private handleTrailingData() {\n        const endIndex = this.buffer.length + this.offset;\n\n        // If there is no remaining data, we are done.\n        if (this.sectionStart >= endIndex) {\n            return;\n        }\n\n        if (this.state === State.InCommentLike) {\n            if (this.currentSequence === Sequences.CdataEnd) {\n                this.cbs.oncdata(this.sectionStart, endIndex, 0);\n            } else {\n                this.cbs.oncomment(this.sectionStart, endIndex, 0);\n            }\n        } else if (\n            this.state === State.InTagName ||\n            this.state === State.BeforeAttributeName ||\n            this.state === State.BeforeAttributeValue ||\n            this.state === State.AfterAttributeName ||\n            this.state === State.InAttributeName ||\n            this.state === State.InAttributeValueSq ||\n            this.state === State.InAttributeValueDq ||\n            this.state === State.InAttributeValueNq ||\n            this.state === State.InClosingTagName\n        ) {\n            /*\n             * If we are currently in an opening or closing tag, us not calling the\n             * respective callback signals that the tag should be ignored.\n             */\n        } else {\n            this.cbs.ontext(this.sectionStart, endIndex);\n        }\n    }\n\n    private emitCodePoint(cp: number, consumed: number): void {\n        if (\n            this.baseState !== State.Text &&\n            this.baseState !== State.InSpecialTag\n        ) {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.onattribdata(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n\n            this.cbs.onattribentity(cp);\n        } else {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.ontext(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n\n            this.cbs.ontextentity(cp, this.sectionStart);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}