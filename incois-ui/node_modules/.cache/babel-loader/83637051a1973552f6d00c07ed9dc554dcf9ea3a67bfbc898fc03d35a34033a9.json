{"ast":null,"code":"import { removeElement } from 'domutils';\nimport { Document, isDocument as checkIsDocument } from 'domhandler';\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\nexport function getParse(parser) {\n  /**\n   * Parse a HTML string or a node.\n   *\n   * @param content - The HTML string or node.\n   * @param options - The parser options.\n   * @param isDocument - If `content` is a document.\n   * @param context - The context node in the DOM tree.\n   * @returns The parsed document node.\n   */\n  return function parse(content, options, isDocument, context) {\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n      content = content.toString();\n    }\n    if (typeof content === 'string') {\n      return parser(content, options, isDocument, context);\n    }\n    const doc = content;\n    if (!Array.isArray(doc) && checkIsDocument(doc)) {\n      // If `doc` is already a root, just return it\n      return doc;\n    }\n    // Add conent to new root element\n    const root = new Document([]);\n    // Update the DOM using the root\n    update(doc, root);\n    return root;\n  };\n}\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nexport function update(newChilds, parent) {\n  // Normalize\n  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n  // Update parent\n  if (parent) {\n    parent.children = arr;\n  } else {\n    parent = null;\n  }\n  // Update neighbors\n  for (let i = 0; i < arr.length; i++) {\n    const node = arr[i];\n    // Cleanly remove existing nodes from their previous structures.\n    if (node.parent && node.parent.children !== arr) {\n      removeElement(node);\n    }\n    if (parent) {\n      node.prev = arr[i - 1] || null;\n      node.next = arr[i + 1] || null;\n    } else {\n      node.prev = node.next = null;\n    }\n    node.parent = parent;\n  }\n  return parent;\n}","map":{"version":3,"names":["removeElement","Document","isDocument","checkIsDocument","getParse","parser","parse","content","options","context","Buffer","isBuffer","toString","doc","Array","isArray","root","update","newChilds","parent","arr","children","i","length","node","prev","next"],"sources":["D:\\Map\\node_modules\\cheerio\\src\\parse.ts"],"sourcesContent":["import { removeElement } from 'domutils';\nimport {\n  type AnyNode,\n  Document,\n  type ParentNode,\n  isDocument as checkIsDocument,\n} from 'domhandler';\nimport type { InternalOptions } from './options.js';\n\n/**\n * Get the parse function with options.\n *\n * @param parser - The parser function.\n * @returns The parse function with options.\n */\nexport function getParse(\n  parser: (\n    content: string,\n    options: InternalOptions,\n    isDocument: boolean,\n    context: ParentNode | null,\n  ) => Document,\n) {\n  /**\n   * Parse a HTML string or a node.\n   *\n   * @param content - The HTML string or node.\n   * @param options - The parser options.\n   * @param isDocument - If `content` is a document.\n   * @param context - The context node in the DOM tree.\n   * @returns The parsed document node.\n   */\n  return function parse(\n    content: string | Document | AnyNode | AnyNode[] | Buffer,\n    options: InternalOptions,\n    isDocument: boolean,\n    context: ParentNode | null,\n  ): Document {\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n      content = content.toString();\n    }\n\n    if (typeof content === 'string') {\n      return parser(content, options, isDocument, context);\n    }\n\n    const doc = content as AnyNode | AnyNode[] | Document;\n\n    if (!Array.isArray(doc) && checkIsDocument(doc)) {\n      // If `doc` is already a root, just return it\n      return doc;\n    }\n\n    // Add conent to new root element\n    const root = new Document([]);\n\n    // Update the DOM using the root\n    update(doc, root);\n\n    return root;\n  };\n}\n\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nexport function update(\n  newChilds: AnyNode[] | AnyNode,\n  parent: ParentNode | null,\n): ParentNode | null {\n  // Normalize\n  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n\n  // Update parent\n  if (parent) {\n    parent.children = arr;\n  } else {\n    parent = null;\n  }\n\n  // Update neighbors\n  for (let i = 0; i < arr.length; i++) {\n    const node = arr[i];\n\n    // Cleanly remove existing nodes from their previous structures.\n    if (node.parent && node.parent.children !== arr) {\n      removeElement(node);\n    }\n\n    if (parent) {\n      node.prev = arr[i - 1] || null;\n      node.next = arr[i + 1] || null;\n    } else {\n      node.prev = node.next = null;\n    }\n\n    node.parent = parent;\n  }\n\n  return parent;\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,UAAU;AACxC,SAEEC,QAAQ,EAERC,UAAU,IAAIC,eAAe,QACxB,YAAY;AAGnB;;;;;;AAMA,OAAM,SAAUC,QAAQA,CACtBC,MAKa;EAEb;;;;;;;;;EASA,OAAO,SAASC,KAAKA,CACnBC,OAAyD,EACzDC,OAAwB,EACxBN,UAAmB,EACnBO,OAA0B;IAE1B,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,QAAQ,CAACJ,OAAO,CAAC,EAAE;MAC7DA,OAAO,GAAGA,OAAO,CAACK,QAAQ,EAAE;IAC9B;IAEA,IAAI,OAAOL,OAAO,KAAK,QAAQ,EAAE;MAC/B,OAAOF,MAAM,CAACE,OAAO,EAAEC,OAAO,EAAEN,UAAU,EAAEO,OAAO,CAAC;IACtD;IAEA,MAAMI,GAAG,GAAGN,OAAyC;IAErD,IAAI,CAACO,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,IAAIV,eAAe,CAACU,GAAG,CAAC,EAAE;MAC/C;MACA,OAAOA,GAAG;IACZ;IAEA;IACA,MAAMG,IAAI,GAAG,IAAIf,QAAQ,CAAC,EAAE,CAAC;IAE7B;IACAgB,MAAM,CAACJ,GAAG,EAAEG,IAAI,CAAC;IAEjB,OAAOA,IAAI;EACb,CAAC;AACH;AAEA;;;;;;;AAOA,OAAM,SAAUC,MAAMA,CACpBC,SAA8B,EAC9BC,MAAyB;EAEzB;EACA,MAAMC,GAAG,GAAGN,KAAK,CAACC,OAAO,CAACG,SAAS,CAAC,GAAGA,SAAS,GAAG,CAACA,SAAS,CAAC;EAE9D;EACA,IAAIC,MAAM,EAAE;IACVA,MAAM,CAACE,QAAQ,GAAGD,GAAG;EACvB,CAAC,MAAM;IACLD,MAAM,GAAG,IAAI;EACf;EAEA;EACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,MAAME,IAAI,GAAGJ,GAAG,CAACE,CAAC,CAAC;IAEnB;IACA,IAAIE,IAAI,CAACL,MAAM,IAAIK,IAAI,CAACL,MAAM,CAACE,QAAQ,KAAKD,GAAG,EAAE;MAC/CpB,aAAa,CAACwB,IAAI,CAAC;IACrB;IAEA,IAAIL,MAAM,EAAE;MACVK,IAAI,CAACC,IAAI,GAAGL,GAAG,CAACE,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI;MAC9BE,IAAI,CAACE,IAAI,GAAGN,GAAG,CAACE,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI;IAChC,CAAC,MAAM;MACLE,IAAI,CAACC,IAAI,GAAGD,IAAI,CAACE,IAAI,GAAG,IAAI;IAC9B;IAEAF,IAAI,CAACL,MAAM,GAAGA,MAAM;EACtB;EAEA,OAAOA,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}