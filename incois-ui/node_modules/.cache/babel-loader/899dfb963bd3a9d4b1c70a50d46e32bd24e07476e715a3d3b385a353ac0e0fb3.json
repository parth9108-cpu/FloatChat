{"ast":null,"code":"import { flattenOptions } from './options.js';\nimport * as staticMethods from './static.js';\nimport { Cheerio } from './cheerio.js';\nimport { isHtml, isCheerio } from './utils.js';\nimport { ElementType } from 'htmlparser2';\nexport function getLoad(parse, render) {\n  /**\n   * Create a querying function, bound to a document created from the provided\n   * markup.\n   *\n   * Note that similar to web browser contexts, this operation may introduce\n   * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to\n   * switch to fragment mode and disable this.\n   *\n   * @param content - Markup to be loaded.\n   * @param options - Options for the created instance.\n   * @param isDocument - Allows parser to be switched to fragment mode.\n   * @returns The loaded document.\n   * @see {@link https://cheerio.js.org/docs/basics/loading#load} for additional usage information.\n   */\n  return function load(content, options, isDocument = true) {\n    if (content == null) {\n      throw new Error('cheerio.load() expects a string');\n    }\n    const internalOpts = flattenOptions(options);\n    const initialRoot = parse(content, internalOpts, isDocument, null);\n    /**\n     * Create an extended class here, so that extensions only live on one\n     * instance.\n     */\n    class LoadedCheerio extends Cheerio {\n      _make(selector, context) {\n        const cheerio = initialize(selector, context);\n        cheerio.prevObject = this;\n        return cheerio;\n      }\n      _parse(content, options, isDocument, context) {\n        return parse(content, options, isDocument, context);\n      }\n      _render(dom) {\n        return render(dom, this.options);\n      }\n    }\n    function initialize(selector, context, root = initialRoot, opts) {\n      // $($)\n      if (selector && isCheerio(selector)) return selector;\n      const options = flattenOptions(opts, internalOpts);\n      const r = typeof root === 'string' ? [parse(root, options, false, null)] : 'length' in root ? root : [root];\n      const rootInstance = isCheerio(r) ? r : new LoadedCheerio(r, null, options);\n      // Add a cyclic reference, so that calling methods on `_root` never fails.\n      rootInstance._root = rootInstance;\n      // $(), $(null), $(undefined), $(false)\n      if (!selector) {\n        return new LoadedCheerio(undefined, rootInstance, options);\n      }\n      const elements = typeof selector === 'string' && isHtml(selector) ?\n      // $(<html>)\n      parse(selector, options, false, null).children : isNode(selector) ?\n      // $(dom)\n      [selector] : Array.isArray(selector) ?\n      // $([dom])\n      selector : undefined;\n      const instance = new LoadedCheerio(elements, rootInstance, options);\n      if (elements) {\n        return instance;\n      }\n      if (typeof selector !== 'string') {\n        throw new TypeError('Unexpected type of selector');\n      }\n      // We know that our selector is a string now.\n      let search = selector;\n      const searchContext = context ?\n      // If we don't have a context, maybe we have a root, from loading\n      typeof context === 'string' ? isHtml(context) ?\n      // $('li', '<ul>...</ul>')\n      new LoadedCheerio([parse(context, options, false, null)], rootInstance, options) : (\n      // $('li', 'ul')\n      search = `${context} ${search}`, rootInstance) : isCheerio(context) ?\n      // $('li', $)\n      context :\n      // $('li', node), $('li', [nodes])\n      new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options) : rootInstance;\n      // If we still don't have a context, return\n      if (!searchContext) return instance;\n      /*\n       * #id, .class, tag\n       */\n      return searchContext.find(search);\n    }\n    // Add in static methods & properties\n    Object.assign(initialize, staticMethods, {\n      load,\n      // `_root` and `_options` are used in static methods.\n      _root: initialRoot,\n      _options: internalOpts,\n      // Add `fn` for plugins\n      fn: LoadedCheerio.prototype,\n      // Add the prototype here to maintain `instanceof` behavior.\n      prototype: LoadedCheerio.prototype\n    });\n    return initialize;\n  };\n}\nfunction isNode(obj) {\n  return (\n    // @ts-expect-error: TS doesn't know about the `name` property.\n    !!obj.name ||\n    // @ts-expect-error: TS doesn't know about the `type` property.\n    obj.type === ElementType.Root ||\n    // @ts-expect-error: TS doesn't know about the `type` property.\n    obj.type === ElementType.Text ||\n    // @ts-expect-error: TS doesn't know about the `type` property.\n    obj.type === ElementType.Comment\n  );\n}","map":{"version":3,"names":["flattenOptions","staticMethods","Cheerio","isHtml","isCheerio","ElementType","getLoad","parse","render","load","content","options","isDocument","Error","internalOpts","initialRoot","LoadedCheerio","_make","selector","context","cheerio","initialize","prevObject","_parse","_render","dom","root","opts","r","rootInstance","_root","undefined","elements","children","isNode","Array","isArray","instance","TypeError","search","searchContext","find","Object","assign","_options","fn","prototype","obj","name","type","Root","Text","Comment"],"sources":["D:\\Map\\node_modules\\cheerio\\src\\load.ts"],"sourcesContent":["import {\n  type CheerioOptions,\n  type InternalOptions,\n  flattenOptions,\n} from './options.js';\nimport * as staticMethods from './static.js';\nimport { Cheerio } from './cheerio.js';\nimport { isHtml, isCheerio } from './utils.js';\nimport type { AnyNode, Document, Element, ParentNode } from 'domhandler';\nimport type { SelectorType, BasicAcceptedElems } from './types.js';\nimport { ElementType } from 'htmlparser2';\n\ntype StaticType = typeof staticMethods;\n\n/**\n * A querying function, bound to a document created from the provided markup.\n *\n * Also provides several helper methods for dealing with the document as a\n * whole.\n */\nexport interface CheerioAPI extends StaticType {\n  /**\n   * This selector method is the starting point for traversing and manipulating\n   * the document. Like jQuery, it's the primary method for selecting elements\n   * in the document.\n   *\n   * `selector` searches within the `context` scope, which searches within the\n   * `root` scope.\n   *\n   * @example\n   *\n   * ```js\n   * $('ul .pear').attr('class');\n   * //=> pear\n   *\n   * $('li[class=orange]').html();\n   * //=> Orange\n   *\n   * $('.apple', '#fruits').text();\n   * //=> Apple\n   * ```\n   *\n   * Optionally, you can also load HTML by passing the string as the selector:\n   *\n   * ```js\n   * $('<ul id=\"fruits\">...</ul>');\n   * ```\n   *\n   * Or the context:\n   *\n   * ```js\n   * $('ul', '<ul id=\"fruits\">...</ul>');\n   * ```\n   *\n   * Or as the root:\n   *\n   * ```js\n   * $('li', 'ul', '<ul id=\"fruits\">...</ul>');\n   * ```\n   *\n   * @param selector - Either a selector to look for within the document, or the\n   *   contents of a new Cheerio instance.\n   * @param context - Either a selector to look for within the root, or the\n   *   contents of the document to query.\n   * @param root - Optional HTML document string.\n   */\n  <T extends AnyNode, S extends string>(\n    selector?: S | BasicAcceptedElems<T>,\n    context?: BasicAcceptedElems<AnyNode> | null,\n    root?: BasicAcceptedElems<Document>,\n    options?: CheerioOptions,\n  ): Cheerio<S extends SelectorType ? Element : T>;\n\n  /**\n   * The root the document was originally loaded with.\n   *\n   * @private\n   */\n  _root: Document;\n\n  /**\n   * The options the document was originally loaded with.\n   *\n   * @private\n   */\n  _options: InternalOptions;\n\n  /** Mimic jQuery's prototype alias for plugin authors. */\n  fn: typeof Cheerio.prototype;\n\n  /**\n   * The `.load` static method defined on the \"loaded\" Cheerio factory function\n   * is deprecated. Users are encouraged to instead use the `load` function\n   * exported by the Cheerio module.\n   *\n   * @deprecated Use the `load` function exported by the Cheerio module.\n   * @category Deprecated\n   * @example\n   *\n   * ```js\n   * const $ = cheerio.load('<h1>Hello, <span>world</span>.</h1>');\n   * ```\n   */\n  load: ReturnType<typeof getLoad>;\n}\n\nexport function getLoad(\n  parse: Cheerio<AnyNode>['_parse'],\n  render: (\n    dom: AnyNode | ArrayLike<AnyNode>,\n    options: InternalOptions,\n  ) => string,\n) {\n  /**\n   * Create a querying function, bound to a document created from the provided\n   * markup.\n   *\n   * Note that similar to web browser contexts, this operation may introduce\n   * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to\n   * switch to fragment mode and disable this.\n   *\n   * @param content - Markup to be loaded.\n   * @param options - Options for the created instance.\n   * @param isDocument - Allows parser to be switched to fragment mode.\n   * @returns The loaded document.\n   * @see {@link https://cheerio.js.org/docs/basics/loading#load} for additional usage information.\n   */\n  return function load(\n    content: string | AnyNode | AnyNode[] | Buffer,\n    options?: CheerioOptions | null,\n    isDocument = true,\n  ): CheerioAPI {\n    if ((content as string | null) == null) {\n      throw new Error('cheerio.load() expects a string');\n    }\n\n    const internalOpts = flattenOptions(options);\n    const initialRoot = parse(content, internalOpts, isDocument, null);\n\n    /**\n     * Create an extended class here, so that extensions only live on one\n     * instance.\n     */\n    class LoadedCheerio<T> extends Cheerio<T> {\n      _make<T>(\n        selector?: ArrayLike<T> | T | string,\n        context?: BasicAcceptedElems<AnyNode> | null,\n      ): Cheerio<T> {\n        const cheerio = initialize(selector, context);\n        cheerio.prevObject = this;\n\n        return cheerio;\n      }\n\n      _parse(\n        content: string | Document | AnyNode | AnyNode[] | Buffer,\n        options: InternalOptions,\n        isDocument: boolean,\n        context: ParentNode | null,\n      ) {\n        return parse(content, options, isDocument, context);\n      }\n\n      _render(dom: AnyNode | ArrayLike<AnyNode>): string {\n        return render(dom, this.options);\n      }\n    }\n\n    function initialize<T = AnyNode, S extends string = string>(\n      selector?: ArrayLike<T> | T | S,\n      context?: BasicAcceptedElems<AnyNode> | null,\n      root: BasicAcceptedElems<Document> = initialRoot,\n      opts?: CheerioOptions,\n    ): Cheerio<S extends SelectorType ? Element : T> {\n      type Result = S extends SelectorType ? Element : T;\n\n      // $($)\n      if (selector && isCheerio<Result>(selector)) return selector;\n\n      const options = flattenOptions(opts, internalOpts);\n      const r =\n        typeof root === 'string'\n          ? [parse(root, options, false, null)]\n          : 'length' in root\n            ? root\n            : [root];\n      const rootInstance = isCheerio<Document>(r)\n        ? r\n        : new LoadedCheerio<Document>(r, null, options);\n      // Add a cyclic reference, so that calling methods on `_root` never fails.\n      rootInstance._root = rootInstance;\n\n      // $(), $(null), $(undefined), $(false)\n      if (!selector) {\n        return new LoadedCheerio<Result>(undefined, rootInstance, options);\n      }\n\n      const elements: AnyNode[] | undefined =\n        typeof selector === 'string' && isHtml(selector)\n          ? // $(<html>)\n            parse(selector, options, false, null).children\n          : isNode(selector)\n            ? // $(dom)\n              [selector]\n            : Array.isArray(selector)\n              ? // $([dom])\n                selector\n              : undefined;\n\n      const instance = new LoadedCheerio(elements, rootInstance, options);\n\n      if (elements) {\n        return instance as Cheerio<Result>;\n      }\n\n      if (typeof selector !== 'string') {\n        throw new TypeError('Unexpected type of selector');\n      }\n\n      // We know that our selector is a string now.\n      let search = selector;\n\n      const searchContext: Cheerio<AnyNode> | undefined = context\n        ? // If we don't have a context, maybe we have a root, from loading\n          typeof context === 'string'\n          ? isHtml(context)\n            ? // $('li', '<ul>...</ul>')\n              new LoadedCheerio<Document>(\n                [parse(context, options, false, null)],\n                rootInstance,\n                options,\n              )\n            : // $('li', 'ul')\n              ((search = `${context} ${search}` as S), rootInstance)\n          : isCheerio<AnyNode>(context)\n            ? // $('li', $)\n              context\n            : // $('li', node), $('li', [nodes])\n              new LoadedCheerio<AnyNode>(\n                Array.isArray(context) ? context : [context],\n                rootInstance,\n                options,\n              )\n        : rootInstance;\n\n      // If we still don't have a context, return\n      if (!searchContext) return instance as Cheerio<Result>;\n\n      /*\n       * #id, .class, tag\n       */\n      return searchContext.find(search) as Cheerio<Result>;\n    }\n\n    // Add in static methods & properties\n    Object.assign(initialize, staticMethods, {\n      load,\n      // `_root` and `_options` are used in static methods.\n      _root: initialRoot,\n      _options: internalOpts,\n      // Add `fn` for plugins\n      fn: LoadedCheerio.prototype,\n      // Add the prototype here to maintain `instanceof` behavior.\n      prototype: LoadedCheerio.prototype,\n    });\n\n    return initialize as CheerioAPI;\n  };\n}\n\nfunction isNode(obj: unknown): obj is AnyNode {\n  return (\n    // @ts-expect-error: TS doesn't know about the `name` property.\n    !!obj.name ||\n    // @ts-expect-error: TS doesn't know about the `type` property.\n    obj.type === ElementType.Root ||\n    // @ts-expect-error: TS doesn't know about the `type` property.\n    obj.type === ElementType.Text ||\n    // @ts-expect-error: TS doesn't know about the `type` property.\n    obj.type === ElementType.Comment\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}